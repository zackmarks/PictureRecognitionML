# -*- coding: utf-8 -*-
"""prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OGwrggb4NFQzuhE_EkRluoMaxcVJEE54
"""

#Zachary (Zack) Marks
#8872996
#teamname on codelab: zam

#I worked in Google colab, so there are some oddities that might be different when you test the data

# Commented out IPython magic to ensure Python compatibility.
#did a similar project in my cs190i class. many of these imports and other parts of the project are copied in from that
import os
import io
import random
import numpy as np
import pandas as pd
from tqdm import tqdm

from skimage.io import imread
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision import transforms

from torch.utils.data import Dataset
from torchvision import datasets
from torchvision.transforms import ToTensor
import matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader
from torch.nn import Linear, ReLU, CrossEntropyLoss, Sequential, Conv2d, MaxPool2d, Module, Softmax, BatchNorm2d, Dropout

from PIL import Image, ImageFile

from torch import optim, nn
import torchvision.models as models


import zipfile

#use_deterministic_algorithms()

# set the random seed for reproduction 
SEED=0
random.seed(SEED)
np.random.seed(SEED)
torch.manual_seed(SEED)

# checking if GPU is available or not
device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')



# from zipfile import ZipFile
# with ZipFile("./hw4_test.zip", 'r') as testUpload:
#     testUpload.extractall()

#https://piazza.com/class/lcn0dnfd9ze4h3/post/221

class cnn6(nn.Module):
    def __init__(self):
        super(cnn6, self).__init__()
        #use 28 x 28 x 3 for input
        self.conv1 = nn.Conv2d(in_channels = 3, out_channels = 16, kernel_size = 4, stride = 1)
        #25 x 25 x 16
        self.conv2 = nn.Conv2d(16,32,4,1)
        #22 x 22 x 32

        #11*11*32
        self.fc1 = nn.Linear(3872,16*9)
        self.fc2 = nn.Linear(16*9,10)
    def forward(self,x):
        x = self.conv1(x)
        x = F.relu(x)
        x = self.conv2(x)
        x = F.relu(x)
        x = F.max_pool2d(x,2)#stride is 2
        x = torch.flatten(x,1)
        x = self.fc1(x)
        x = F.relu(x)
        x = self.fc2(x)
        return x


usedCNN = cnn6().to(device)
usedCNN.load_state_dict(torch.load('./model.pth'))

"""https://pytorch.org/tutorials/beginner/basics/data_tutorial.html"""

link = './hw4_test/0.png'
pic = Image.open(link)
picType = (type(pic))
#print((type(pic)) == <class 'PIL.PngImagePlugin.PngImageFile'>)

#test on the testing data
testingImageSet = './hw4_test'
tupVec, sortedTupVec = [], []
k = 0
with torch.no_grad():
    for i in os.listdir(testingImageSet):
        picture = os.path.join(testingImageSet, i)
        try:
            blank = Image.open(picture).convert('RGB')
        except:
            continue
        if type(Image.open(picture)) != picType:
            continue
        transform = transforms.Compose([transforms.ToTensor()])
        blank = transform(blank)
        blank = blank.to(device)
        blank = blank.unsqueeze(0)
        output = usedCNN(blank)
        blank, predicted = torch.max(output.data, 1)
        predicted = predicted.cpu()
        predicted = predicted.numpy()
        pred = str(predicted[0])
        tup = (i,pred)
        tupVec.append(tup)

def getNewName2(fileName):
  part2 = fileName
  zeroesToAdd = 8-len(part2)
  #print(part2, zeroesToAdd)
  retStr = ''
  for i in range(zeroesToAdd):
    retStr += '0'
  retStr += part2
  return retStr


newTupVec = []

for element in tupVec:
    prevName = element[0]
    newName = getNewName2(prevName)
    #element[0] = newName
    tup = (newName, element[1])
    newTupVec.append(tup)

sortTupVec = sorted(newTupVec)
print(sortTupVec)


#write prediction.txt
with open("prediction.txt",'w') as pre:
  for t in sortTupVec:
    pre.write(t[1] + "\n")
    #pre.write("\n")

print(sortTupVec)
#879838

print("wah")